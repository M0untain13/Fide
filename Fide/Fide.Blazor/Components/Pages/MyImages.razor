@page "/myimages"

@using Microsoft.AspNetCore.Authorization;
@using Fide.Blazor.Data;
@using Fide.Blazor.Services.FileStorage
@using Fide.Blazor.Services.AnalysisProxy
@using Fide.Blazor.Services.Data.UnitOfWork
@using Fide.Blazor.Components.Components
@using DTO.Analysis

@inject AuthenticationStateProvider ContextProvider
@inject IUnitOfWork uow
@inject IFileStorage storage
@inject IAnalysisProxy analysisClient
@attribute [Authorize]

<PageTitle>Мои изображения</PageTitle>

@if (IsCanLeft() || IsCanRight())
{
    <button @onclick="Left" disabled="@(!IsCanLeft())">@("<")</button>
    @(ImagePage + 1)
    <button @onclick="Right" disabled="@(!IsCanRight())">></button>
}

<InputFile OnChange="UploadImages" multiple accept=".jpg" class="inputfile-text" />

@if (User is null)
{
    <p>Загрузка...</p>
}
else
{
    if (User.ImageLinks.Count == 0)
    {
        <p>У Вас пока что нет изображений</p>
    }
    else
    {
        <Grid Source="RenderImages">
            <Image 
                ImageLink="context" 
                OnDelete="DeleteImage" 
                OnAnalyze="AnalisysImage" 
                />
        </Grid>
    }
}

@code {
    private IEnumerable<ImageLink> RenderImages => User.ImageLinks.OrderBy(i => i.Id).Skip(AmountImagesByPage * ImagePage).Take(AmountImagesByPage);

    private ApplicationUser? User { get; set; }

    private int ImagePage { get; set; } = 0;

    private int AmountImagesByPage { get; set; } = 12;

    private async Task UploadImages(InputFileChangeEventArgs e)
    {
        var files = e.GetMultipleFiles();

        var fileStreams = new List<Stream>();

        var users = uow.GetRepository<ApplicationUser>();
        var images = uow.GetRepository<ImageLink>();
        var maxbytes = 5120000;
        foreach(var file in files)
        {
            if (file.ContentType == "image/jpeg"
                && file.Size <= maxbytes)
            {
                var nameInBucket = await storage.UploadFileAsync(file.OpenReadStream(maxbytes), file.Name);
                var image = new ImageLink()
                {
                    OriginalName = nameInBucket,
                };
                await images.AddAsync(image);
                User.ImageLinks.Add(image);
                users.Update(User);
            }
        }
        await uow.CommitAsync();
    }

    private async Task DeleteImage(ImageLink imageLink)
    {
        var users = uow.GetRepository<ApplicationUser>();
        var images = uow.GetRepository<ImageLink>();

        User.ImageLinks.Remove(imageLink);
        users.Update(User);

        await storage.DeleteFileAsync(imageLink.OriginalName);
        if (imageLink.AnalysisName is not null)
        {
            await storage.DeleteFileAsync(imageLink.AnalysisName);
        }
        images.Remove(imageLink);

        await uow.CommitAsync();

        if(IsCanLeft() && User.ImageLinks.Count - (AmountImagesByPage * ImagePage) == 0)
        {
            Left();
        }
    }

    private async Task AnalisysImage(ImageLink imageLink)
    {
        if(imageLink.AnalysisName is null)
        {
            var request = new AnalysisRequest()
            {
                // TODO: исправить захардкоженный бакет
                BucketName = "filesbucket",
                ObjectName = imageLink.OriginalName
            };
            var response = await analysisClient.SendAsync(request);
            imageLink.AnalysisName = response.ObjectName;

            var images = uow.GetRepository<ImageLink>();
            images.Update(imageLink);
            await uow.CommitAsync();
        }
    }

    private bool IsCanLeft() => ImagePage > 0;
    private bool IsCanRight() => User is not null ? User.ImageLinks.Count - (AmountImagesByPage * (ImagePage + 1)) > 0 : false;

    private void Left()
    {
        if (IsCanLeft())
        {
            ImagePage--;
        }
    }

    private void Right()
    {
        if (IsCanRight())
        {
            ImagePage++;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var context = await ContextProvider.GetAuthenticationStateAsync();
        var users = uow.GetRepository<ApplicationUser>();
        var name = context.User.Identity?.Name;
        User = (await users.FindAsync(u => u.UserName == name)).FirstOrDefault();
    }
}
